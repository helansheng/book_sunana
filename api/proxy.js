// /api/proxy.js// 导出 Vercel Serverless Functionexport default async function handler(request, response) {    // 1. 只接受 POST 请求    if (request.method !== 'POST') {        return response.status(405).json({ error: 'Method Not Allowed' });    }    try {        // 2. 从前端请求中获取真正的 API Key 和请求体        const { apiKey, body } = request.body;        if (!apiKey || !body) {            return response.status(400).json({ error: 'Missing apiKey or body in the request' });        }        const modelName = 'gemini-2.5-pro'; // 我们可以在代理中固定模型，或者也让前端传过来        // 注意：这里我们收到了用户的API Key，然后用它去请求Google        const googleApiUrl = `https://generativelanguage.googleapis.com/v1beta/models/${modelName}:generateContent?key=${apiKey}`;        // 3. 代替前端，向 Google API 发起请求        const googleResponse = await fetch(googleApiUrl, {            method: 'POST',            headers: {                'Content-Type': 'application/json',            },            body: JSON.stringify(body), // 将前端传来的请求体转发给Google        });        // 4. 获取 Google 的响应        const googleData = await googleResponse.json();                // 5. 将 Google 的响应原封不动地返回给前端        // 我们也把Google返回的状态码（如200, 429等）一并返回        response.status(googleResponse.status).json(googleData);    } catch (error) {        console.error('Proxy Error:', error);        response.status(500).json({ error: 'An internal server error occurred in the proxy.' });    }}