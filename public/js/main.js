document.addEventListener('DOMContentLoaded', () => {    // 配置区域    const PROXY_ENDPOINT = '/proxy';    const API_TIMEOUT_MS = 45000; // 设置45秒的API请求超时    // DOM元素    const searchBtn = document.getElementById('search-btn');    const queryInput = document.getElementById('query-input');    const resultsContainer = document.getElementById('results-container');    const loadingSpinner = document.getElementById('loading-spinner');    const infoBox = document.getElementById('info-box');    const settingsBtn = document.getElementById('settings-btn');    const settingsModal = document.getElementById('settings-modal');    const closeModalBtn = document.getElementById('close-modal-btn');    const addKeyBtn = document.getElementById('add-key-btn');    const apiKeyInput = document.getElementById('api-key-input');    const keyListUl = document.getElementById('key-list-ul');    let apiKeys = [];    let currentKeyIndex = 0;    // 主处理函数    async function handleSearch() {        if (apiKeys.length === 0) { alert("请先设置 API Key。"); return; }        const query = queryInput.value.trim();        if (query === "") { alert("请输入您的阅读需求！"); return; }                currentKeyIndex = 0;        infoBox.style.display = 'none';        setLoadingState(true, '智能分析中，请稍候...');        try {            const planPromise = (async () => {                setLoadingState(true, '第一步：生成概念计划...');                const initialPlan = await fetchAIResponseWithProxy(buildInitialPrompt(query));                setLoadingState(true, '第二步：核查并优化书单...');                const refinedPlan = await fetchAIResponseWithProxy(buildRefinementPrompt(initialPlan));                setLoadingState(true, '第三步：评估可用性...');                const finalPlan = await fetchAIResponseWithProxy(buildAvailabilityPrompt(refinedPlan));                return finalPlan;            })();            const resourcesPromise = fetchAIResponseWithProxy(buildResourceFinderPrompt());            const [finalPlan, resourceList] = await Promise.all([planPromise, resourcesPromise]);                        displayResults(finalPlan, resourceList);        } catch (error) {            console.error('最终错误:', error);            displayError(error.message); // 只在所有重试都失败后，才显示最终错误        } finally {            setLoadingState(false);        }    }    // =======================================================    // 核心升级：带有超时和健壮重试机制的API调用函数    // =======================================================    async function fetchAIResponseWithProxy(promptBody) {        if (currentKeyIndex >= apiKeys.length) {            throw new Error("您提供的所有API Key都已尝试过或均无效/超时。");        }        const currentKey = apiKeys[currentKeyIndex];                // 创建 AbortController 实现超时        const controller = new AbortController();        const timeoutId = setTimeout(() => {            console.warn(`API 请求超时 (${API_TIMEOUT_MS / 1000}秒)，中止请求...`);            controller.abort();        }, API_TIMEOUT_MS);        try {            const response = await fetch(PROXY_ENDPOINT, {                method: 'POST',                headers: { 'Content-Type': 'application/json' },                body: JSON.stringify({ apiKey: currentKey, body: promptBody }),                signal: controller.signal // 关联 AbortController            });            // 请求成功，清除超时定时器            clearTimeout(timeoutId);            if (!response.ok) {                // 对于任何服务器端错误（如429, 500, 503），都直接抛出，由catch块处理重试                const errorData = await response.json().catch(() => ({}));                const errorMessage = errorData.error?.message || `服务器返回错误，状态码: ${response.status}`;                throw new Error(errorMessage);            }                        const data = await response.json();                        if (!data.candidates || data.candidates.length === 0) {                throw new Error("API响应格式不正确，缺少'candidates'。");            }            const rawText = data.candidates[0].content.parts[0].text;            return JSON.parse(extractJson(rawText));        } catch (error) {            // 请求成功后也要清除定时器            clearTimeout(timeoutId);            // 检查是否是我们的主动超时错误            if (error.name === 'AbortError') {                console.warn(`Key ${currentKey.substring(0,4)}... 超时，尝试下一个Key...`);                currentKeyIndex++;                return fetchAIResponseWithProxy(promptBody); // 递归重试            }                        // 检查是否是其他网络错误或服务器错误            if (error instanceof TypeError || error.message.includes("服务器返回错误")) {                 console.warn(`Key ${currentKey.substring(0,4)}... 遭遇网络或服务器错误，尝试下一个Key...`, error.message);                 currentKeyIndex++;                 return fetchAIResponseWithProxy(promptBody); // 递归重试            }            // 如果是JSON解析错误，则不再重试，直接抛出            if (error instanceof SyntaxError) {                throw new Error("AI返回的数据格式不正确，无法解析为JSON。");            }                        // 其他未知错误，直接抛出            throw error;        }    }        // --- 以下是其他所有未变动或微调的辅助函数 (为了完整性，全部附上) ---    function displayResults(data,resourceList){resultsContainer.innerHTML="",infoBox.style.display="block",data.planTitle&&Array.isArray(data.books)?(()=>{const e=document.createElement("h2");e.className="plan-title",e.style.textAlign="center",e.style.marginBottom="20px",e.textContent=data.planTitle,resultsContainer.appendChild(e);const t=resourceList?.anna_archive||[],s=resourceList?.z_library||[];data.books.forEach((o,n)=>{const a=document.createElement("div");a.className="result-card";const r=encodeURIComponent(o.searchQuery),l=`https://annas-archive.org/search?q=${r}`,c=[{url:l,name:"Official Site"},...t.map(i=>{try{return{url:`${new URL(i).origin}/search?q=${r}`,name:new URL(i).hostname}}catch(e){return null}}).filter(Boolean)],d=createDropdownHTML(`anna-archive-${n}`,"Anna's Archive",c),p=`https://singlelogin.re/s/${r}`,u=[{url:p,name:"Official Site"},...s.map(i=>{try{return{url:`${new URL(i).origin}/s?q=${r}`,name:new URL(i).hostname}}catch(e){return null}}).filter(Boolean)],m=createDropdownHTML(`z-library-${n}`,"Z-Library",u);let g="",b="";o.availability&&(("HIGHLY_LIKELY"===o.availability.anna_archive_status?statusClass="status-high":"RARE"===o.availability.anna_archive_status?statusClass="status-low":statusClass="status-medium",g=`<div class="availability-section"><strong>资源可用性评估: </strong><span class="status-tag ${statusClass}">${o.availability.anna_archive_status.replace(/_/g," ")}</span><p class="availability-note">${o.availability.note}</p></div>")),o.availability&&o.availability.fallbacks&&o.availability.fallbacks.length>0&&(b+='<div class="fallbacks-section"><strong>备用查找途径:</strong> ',o.availability.fallbacks.forEach(i=>{b+=i.name==="ManyBooks"&&i.availability_note?`\n                            <div class="fallback-item-with-note">\n                                <a href="${i.url}" target="_blank" class="fallback-link">${i.name}</a>\n                                <span class="fallback-note">(${i.availability_note})</span>\n                            </div>\n                        `:`<a href="${i.url}" target="_blank" class="fallback-link">${i.name}</a>`}),b+="</div>"),a.innerHTML=`\n                <h2>${o.stage}</h2>\n                <p class="book-title">${o.title} - ${o.author}</p>\n                ${g}\n                <p><strong>书籍简介：</strong>${o.summary}</p>\n                <p><strong>推荐理由：</strong>${o.reason}</p>\n                <div class="links-container">\n                    ${d}\n                    ${m}\n                    ${b}\n                </div>\n            `,resultsContainer.appendChild(a)})})():displayError("AI返回的阅读计划格式不正确，无法解析。")}    function createDropdownHTML(e,t,s){let o=`<div class="mirror-links-dropdown" id="${e}" style="display:none;">`;return s&&s.length>0?s.forEach(n=>{const a="Official Site"===n.name;o+=`<a href="${n.url}" target="_blank" class="mirror-link ${a?"official-link":""}">${n.name} ${a?" (官网)":""}</a>`}):o+='<span class="mirror-link-error">未能获取到可用地址。</span>',o+="</div>",`<div class="links-wrapper"><button class="toggle-btn" data-target="${e}">${t}</button>${o}</div>`}    function buildInitialPrompt(e){const t=`你是一个博学且专业的阅读计划助手。你的任务是根据用户的需求，为其推荐一个结构化的阅读计划。你必须严格按照以下JSON格式返回你的推荐，除了这个JSON对象外，不要包含任何其他文字、解释或注释。JSON格式定义如下：{"planTitle": "关于用户需求的阅读计划标题", "books": [{"stage": "第一阶段：入门与概览", "title": "书籍A的完整标题", "author": "作者A", "summary": "书籍A的简要介绍。", "reason": "推荐这本书的理由。", "searchQuery": "作者A 书籍A的完整标题"}]}`;return{contents:[{role:"user",parts:[{text:t},{text:"用户需求如下："},{text:e}]}],generationConfig:{response_mime_type:"application/json"}}}    function buildRefinementPrompt(e){const t=`你是一个严谨的图书信息事实核查员。你的任务是接收一个JSON格式的初步阅读计划，并对其进行审查和优化，然后返回一个格式完全相同但信息更精准的JSON对象。审查规则：1. 核对作者：修正为该书最广为人知、最权威的作者。2. 优化书名：使用最常见、最容易被搜索到的版本。3. 保持结构：不要更改 "stage", "summary", "reason" 字段。4. 更新searchQuery：根据你修正后的权威作者和书名，生成一个最优化的新 "searchQuery" 字段。除了修正后的JSON对象，绝对不要返回任何其他文字。`,s=JSON.stringify(e,null,2);return{contents:[{role:"user",parts:[{text:t},{text:"这是需要你审查和优化的初步阅读计划JSON："},{text:s}]}],generationConfig:{response_mime_type:"application/json"}}}    function buildAvailabilityPrompt(e){const t=`\n你是一个资深的数字资源馆员，对全球各大开放图书馆和学术数据库的馆藏规律了如指掌。\n你的任务是接收一个经过事实核查的、信息精准的JSON阅读计划，并为其扩充“可用性评估”信息，然后返回一个结构增强的JSON对象。\n\n增强规则如下：\n1.  为每本书添加 "availability" 字段，该字段是一个对象。\n2.  在 "availability" 对象中，评估在 Anna's Archive 的存在可能性 ("anna_archive_status": "HIGHLY_LIKELY" | "UNCERTAIN" | "RARE") 并提供说明 ("note")。\n3.  **深度探索备用资源 (Fallbacks)**：\n    *   "fallbacks" 字段应为一个对象数组。\n    *   **必须包含** Google Books 和 Open Library 的标准搜索链接。\n    *   **特别针对 manybooks.net**：\n        a.  构建一个指向 manybooks.net 搜索结果页的精确URL。\n        b.  添加一个 "availability_note" 字段，用一句话评估在该网站找到这本书的可能性（例如，“该网站以公版英文书为主，找到此中文现代书籍的可能性较低。”或“作为经典英文文学，有较高概率找到。”）。\n4.  **严格的JSON输出**，保持原始数据不变。\n\n增强后的 "fallbacks" 对象中的一个元素应如下所示：\n{ \n  "name": "ManyBooks", \n  "url": "https://manybooks.net/search-book?search=...",\n  "availability_note": "关于在该网站找到此书可能性的简短说明。"\n}`,s=JSON.stringify(e,null,2);return{contents:[{role:"user",parts:[{text:t},{text:"这是需要你评估和增强的阅读计划JSON："},{text:s}]}],generationConfig:{response_mime_type:"application/json"}}}    function buildResourceFinderPrompt(){const e=`\n你是一位精通全球互联网资源访问的专家，且将用户安全置于首位。你的任务是提供当前最有可能在中国大陆地区可用的 Anna's Archive 和 Z-Library 镜像网站地址列表。\n\nCRITICAL SAFETY RULE: 你必须严格审查你提供的每一个URL。绝对禁止 (ABSOLUTELY PROHIBIT) 提供任何已知托管成人内容、恶意软件、赌博或任何非法信息的网站。你的首要职责是确保所有链接都是安全且仅与图书下载相关的。\n\n规则：\n1. 返回一个JSON对象，包含两个键: "anna_archive" 和 "z_library"。\n2. 每个键对应的值是一个包含2到4个URL字符串的数组。\n3. 这些URL应基于你最新知识库，选择最稳定、最被社群推荐的、经过安全验证的镜像地址。\n4. 只提供镜像地址，不要包含官网主站。\n5. 除了这个JSON对象，绝对不要返回任何其他文字、解释或注释。\n\n示例输出:\n{\n  "anna_archive": ["https://annas-archive.gs", "https://annas-archive.se"],\n  "z_library": ["https://z-lib.is", "https://z-lib.id"]\n}\n`;return{contents:[{role:"user",parts:[{text:e}]}],generationConfig:{response_mime_type:"application/json"}}}    function extractJson(e){const t=e.match(/```json\s*([\s\S]*?)\s*```/);return t&&t[1]?t[1]:e}    function displayError(e){setLoadingState(!1),resultsContainer.innerHTML=`<div class="error-message"><h3>糟糕，出错了！</h3><p>${e}</p><p>请检查你的网络连接和API Key配置，然后重试。</p></div>`}    function setLoadingState(e,t){searchBtn.disabled=e,e?(searchBtn.textContent=t,resultsContainer.innerHTML="",loadingSpinner.style.display="block",resultsContainer.appendChild(loadingSpinner)):(searchBtn.textContent="生成阅读计划",loadingSpinner.style.display="none")}    function loadKeysFromStorage(){const e=localStorage.getItem("geminiApiKeys");apiKeys=e?JSON.parse(e):[],updateUIOnKeyChange(),renderKeyList()}    function saveKeysToStorage(){localStorage.setItem("geminiApiKeys",JSON.stringify(apiKeys))}    function renderKeyList(){if(keyListUl.innerHTML="",0===apiKeys.length)return void(keyListUl.innerHTML="<li>暂无 API Key。</li>");apiKeys.forEach((e,t)=>{const s=`${e.substring(0,4)}...${e.substring(e.length-4)}`,o=document.createElement("li");o.innerHTML=`<span>${s}</span><button class="delete-key-btn" data-index="${t}" title="删除">&times;</button>`,keyListUl.appendChild(o)})}    function addKey(){const e=apiKeyInput.value.trim();e&&!apiKeys.includes(e)?(apiKeys.push(e),saveKeysToStorage(),renderKeyList(),updateUIOnKeyChange(),apiKeyInput.value=""):apiKeys.includes(e)&&alert("这个 API Key 已经存在了。")}    function deleteKey(e){apiKeys.splice(e,1),saveKeysToStorage(),renderKeyList(),updateUIOnKeyChange()}    function updateUIOnKeyChange(){0===apiKeys.length?(searchBtn.disabled=!0,searchBtn.textContent="请先设置 API Key"):(searchBtn.disabled=!1,searchBtn.textContent="生成阅读计划")}    searchBtn.addEventListener("click",handleSearch),settingsBtn.addEventListener("click",()=>{settingsModal.style.display="flex"}),closeModalBtn.addEventListener("click",()=>{settingsModal.style.display="none"}),settingsModal.addEventListener("click",e=>{e.target===settingsModal&&(settingsModal.style.display="none")}),addKeyBtn.addEventListener("click",addKey),apiKeyInput.addEventListener("keyup",e=>{"Enter"===e.key&&addKey()}),keyListUl.addEventListener("click",e=>{if(e.target.classList.contains("delete-key-btn")){const t=parseInt(e.target.dataset.index,10);deleteKey(t)}});    resultsContainer.addEventListener('click', (event) => {        if (event.target.classList.contains('toggle-btn')) {            const targetId = event.target.dataset.target;            const dropdown = document.getElementById(targetId);            if (dropdown) {                dropdown.style.display = dropdown.style.display === 'none' ? 'block' : 'none';            }        }    });    loadKeysFromStorage();});