document.addEventListener('DOMContentLoaded', () => {    // 配置区域    const PROXY_ENDPOINT = '/proxy';    // DOM元素    const searchBtn = document.getElementById('search-btn');    const queryInput = document.getElementById('query-input');    const resultsContainer = document.getElementById('results-container');    const loadingSpinner = document.getElementById('loading-spinner');    const infoBox = document.getElementById('info-box');    const settingsBtn = document.getElementById('settings-btn');    const settingsModal = document.getElementById('settings-modal');    const closeModalBtn = document.getElementById('close-modal-btn');    const addKeyBtn = document.getElementById('add-key-btn');    const apiKeyInput = document.getElementById('api-key-input');    const keyListUl = document.getElementById('key-list-ul');    let apiKeys = [];    let currentKeyIndex = 0;    // 主处理函数 - 四步AI策略    async function handleSearch() {        if (apiKeys.length === 0) {            alert("请点击右上角的设置按钮 ⚙️ 添加您的 Google Gemini API Key。");            return;        }        const query = queryInput.value.trim();        if (query === "") {            alert("请输入您的阅读需求！");            return;        }                currentKeyIndex = 0;        infoBox.style.display = 'none';        setLoadingState(true, '第一步：生成概念计划...');        try {            const initialPlan = await fetchAIResponseWithProxy(buildInitialPrompt(query));            setLoadingState(true, '第二步：核查并优化书单...');            const refinedPlan = await fetchAIResponseWithProxy(buildRefinementPrompt(initialPlan));            setLoadingState(true, '第三步：评估可用性...');            const finalPlan = await fetchAIResponseWithProxy(buildAvailabilityPrompt(refinedPlan));            setLoadingState(true, '第四步：寻找可用访问路径...');            const mirrorList = await fetchAIResponseWithProxy(buildMirrorFinderPrompt());            displayResults(finalPlan, mirrorList);        } catch (error) {            console.error('发生错误:', error);            displayError(error.message);        } finally {            setLoadingState(false);        }    }    // 结果渲染函数    function displayResults(data, mirrorList) {        resultsContainer.innerHTML = '';         infoBox.style.display = 'block';        if (!data.planTitle || !Array.isArray(data.books)) {            displayError("AI返回的数据格式不正确，无法解析。");            return;        }        const planTitleElement = document.createElement('h2');        planTitleElement.className = 'plan-title';        planTitleElement.style.textAlign = 'center';        planTitleElement.style.marginBottom = '20px';        planTitleElement.textContent = data.planTitle;        resultsContainer.appendChild(planTitleElement);        data.books.forEach(book => {            const card = document.createElement('div');            card.className = 'result-card';                        let annaHtml = `<button class="anna-toggle-btn">在 Anna's Archive 中查找</button>`;            let mirrorLinksHtml = `<div class="mirror-links-dropdown" style="display:none;">`;            if (mirrorList && Array.isArray(mirrorList) && mirrorList.length > 0) {                 mirrorList.forEach(mirror => {                    try {                        const searchUrl = `${new URL(mirror).origin}/search?q=${encodeURIComponent(book.searchQuery)}`;                        const domain = new URL(mirror).hostname;                        mirrorLinksHtml += `<a href="${searchUrl}" target="_blank" class="mirror-link">${domain}</a>`;                    } catch(e) { console.warn("Invalid mirror URL from AI:", mirror); }                });            } else {                mirrorLinksHtml += `<span class="mirror-link-error">未能获取到可用镜像地址。</span>`;            }            mirrorLinksHtml += `</div>`;                        let availabilityHtml = '';            if (book.availability) {                let statusClass = 'status-medium';                if (book.availability.anna_archive_status === 'HIGHLY_LIKELY') statusClass = 'status-high';                else if (book.availability.anna_archive_status === 'RARE') statusClass = 'status-low';                                availabilityHtml += `<div class="availability-section">                    <strong>资源可用性评估: </strong><span class="status-tag ${statusClass}">${book.availability.anna_archive_status.replace('_', ' ')}</span>                    <p class="availability-note">${book.availability.note}</p>                </div>`;            }            let fallbacksHtml = '';            if (book.availability && book.availability.fallbacks && book.availability.fallbacks.length > 0) {                fallbacksHtml += `<div class="fallbacks-section"><strong>备用查找途径:</strong> `;                book.availability.fallbacks.forEach(link => {                    fallbacksHtml += `<a href="${link.url}" target="_blank" class="fallback-link">${link.name}</a>`;                });                fallbacksHtml += `</div>`;            }                        card.innerHTML = `                <h2>${book.stage}</h2>                <p class="book-title">${book.title} - ${book.author}</p>                <p><strong>书籍简介：</strong>${book.summary}</p>                <p><strong>推荐理由：</strong>${book.reason}</p>                ${availabilityHtml}                <div class="links-container">                    <div class="anna-links-wrapper">                        ${annaHtml}                        ${mirrorLinksHtml}                    </div>                    ${fallbacksHtml}                </div>            `;            resultsContainer.appendChild(card);        });    }    // AI Prompt 构建函数    function buildInitialPrompt(userQuery){const t=`\n你是一个博学且专业的阅读计划助手。你的任务是根据用户的需求，为其推荐一个结构化的阅读计划。\n你必须严格按照以下JSON格式返回你的推荐，除了这个JSON对象外，不要包含任何其他文字、解释或注释。\n\nJSON格式定义如下：\n{\n  "planTitle": "关于用户需求的阅读计划标题",\n  "books": [\n    {\n      "stage": "第一阶段：入门与概览",\n      "title": "书籍A的完整标题",\n      "author": "作者A",\n      "summary": "书籍A的简要介绍，说明其核心内容和特点。",\n      "reason": "推荐这本书作为第一阶段阅读的理由，比如为什么它适合入门。",\n      "searchQuery": "作者A 书籍A的完整标题"\n    }\n  ]\n}\n\n- "stage" 字段描述了阅读的不同阶段。\n- "searchQuery" 字段应提供一个最优化的、用于在图书搜索引擎中查找该书的关键词组合，通常是“作者 书名”。\n- 推荐的书籍数量应在3到5本之间，形成一个有逻辑递进关系的阅读路径。\n`;return{contents:[{parts:[{text:t}]},{parts:[{text:"用户需求如下："},{text:userQuery}]}],generationConfig:{response_mime_type:"application/json"}}}    function buildRefinementPrompt(e){const t=`\n你是一个严谨的图书信息事实核查员，并且对大型数字图书馆（如Anna's Archive）的馆藏非常熟悉。\n你的任务是接收一个JSON格式的初步阅读计划，并对其进行审查和优化，然后返回一个格式完全相同但信息更精准的JSON对象。\n\n审查规则如下：\n1.  **核对作者**：对于书单中的每一本书，根据你的海量知识库，判断其作者是否正确。如果作者有误或不够知名，请将其修正为该书最广为人知、最权威的作者。\n2.  **优化书名**：如果书名有多个版本或副标题，请使用最常见、最容易被搜索到的那个版本。\n3.  **保持结构**：你必须返回与输入格式完全一致的JSON。不要更改 "stage", "summary", "reason" 字段的内容，只专注于修正 "title", "author", 和 "searchQuery"。\n4.  **更新searchQuery**：根据你修正后的权威作者和书名，生成一个最优化的新 "searchQuery" 字段。\n\n除了修正后的JSON对象，绝对不要返回任何其他文字、解释或注释。\n`,s=JSON.stringify(e,null,2);return{contents:[{parts:[{text:t}]},{parts:[{text:"这是需要你审查和优化的初步阅读计划JSON："}]},{parts:[{text:s}]}],generationConfig:{response_mime_type:"application/json"}}}    function buildAvailabilityPrompt(e){const t=`\n你是一个资深的数字资源馆员，对全球各大开放图书馆和学术数据库的馆藏规律了如指掌。\n你的任务是接收一个经过事实核查的、信息精准的JSON阅读计划，并为其扩充“可用性评估”信息，然后返回一个结构增强的JSON对象。\n\n增强规则如下：\n1.  **为每本书添加 "availability" 字段**：这个字段是一个对象，包含以下内容：\n    *   "anna_archive_status": "HIGHLY_LIKELY" | "UNCERTAIN" | "RARE" (一个评估该书在Anna's Archive存在的可能性的字符串)。\n    *   "note": "一段关于可用性的简短说明，例如'此书为经典学术著作，有极大概率找到数字版。'或'此书较新/冷门，可能难以找到。'"\n    *   "fallbacks": 一个对象数组，包含备用搜索链接。\n\n2.  **评估可能性**：根据书的作者、标题、出版年份（如果能推断）和主题，做出专业的评估。\n\n3.  **生成后备链接 (Fallbacks)**：至少提供1-2个后备方案，包含以下网站的搜索链接：\n    *   "name": "Google Books", "url": "..."\n    *   "name": "Open Library", "url": "..."\n    *   "name": "Semantic Scholar", "url": "..." (尤其适合学术论文)\n\n4.  **保持原始数据**：除了新增 "availability" 字段，不要修改任何其他已有的字段。\n\n5.  **严格的JSON输出**\n\n增强后的 book 对象结构应如下所示：\n{\n  "stage": "...", "title": "...", "author": "...", "summary": "...", "reason": "...", "searchQuery": "...",\n  "availability": {\n    "anna_archive_status": "HIGHLY_LIKELY", "note": "...",\n    "fallbacks": [\n      { "name": "Google Books", "url": "https://books.google.com/..." },\n      { "name": "Open Library", "url": "https://openlibrary.org/search?q=..." }\n    ]\n  }\n}\n`,s=JSON.stringify(e,null,2);return{contents:[{parts:[{text:t}]},{parts:[{text:"这是需要你评估和增强的阅读计划JSON："},{text:s}]}],generationConfig:{response_mime_type:"application/json"}}}    function buildMirrorFinderPrompt(){const e=`\n你是一位精通全球互联网资源访问的专家。你的任务是提供一个当前最有可能在中国大陆地区可用的 Anna's Archive 镜像网站地址列表。\n\n规则：\n1.  返回一个JSON数组，数组中包含3到5个URL字符串。\n2.  这些URL应该是基于你最新知识库中信息，最稳定、最被社群推荐的镜像地址。\n3.  不要包含主站地址，只提供镜像地址。\n4.  除了这个JSON数组，绝对不要返回任何其他文字、解释或注释。\n\n示例输出:\n["https://annas-archive.gs", "https://annas-archive.se", "https://annas-archive.li"]\n`;return{contents:[{parts:[{text:e}]}],generationConfig:{response_mime_type:"application/json"}}}    // 辅助函数 (API调用, UI状态, Key管理等)    function setLoadingState(e,t="思考中..."){e?(searchBtn.disabled=!0,searchBtn.textContent=t,resultsContainer.innerHTML="",loadingSpinner.style.display="block",resultsContainer.appendChild(loadingSpinner)):(loadingSpinner.style.display="none",searchBtn.disabled=!1,searchBtn.textContent="生成阅读计划")}    async function fetchAIResponseWithProxy(e){if(currentKeyIndex>=apiKeys.length)throw new Error("API Keys 耗尽。");const t=apiKeys[currentKeyIndex];try{const s=await fetch(PROXY_ENDPOINT,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({apiKey:t,body:e})}),o=await s.json();if(429===s.status)return currentKeyIndex++,fetchAIResponseWithProxy(e);if(!s.ok||!o.candidates){const n=o.error?o.error.message:"未知API错误";throw new Error(`API 请求失败: ${n}`)}const a=o.candidates[0].content.parts[0].text;return JSON.parse(extractJson(a))}catch(r){if(r instanceof TypeError)return currentKeyIndex++,fetchAIResponseWithProxy(r);throw r}}    function extractJson(e){const t=e.match(/```json\s*([\s\S]*?)\s*```/);return t&&t[1]?t[1]:e}    function displayError(e){resultsContainer.innerHTML="";const t=document.createElement("div");t.className="error-message",t.innerHTML=`\n            <h3>糟糕，出错了！</h3>\n            <p>${e}</p>\n            <p>请检查你的网络连接和API Key配置，然后重试。</p>\n        `,resultsContainer.appendChild(t)}    function loadKeysFromStorage(){const e=localStorage.getItem("geminiApiKeys");apiKeys=e?JSON.parse(e):[],updateUIOnKeyChange(),renderKeyList()}    function saveKeysToStorage(){localStorage.setItem("geminiApiKeys",JSON.stringify(apiKeys))}    function renderKeyList(){if(keyListUl.innerHTML="",0===apiKeys.length)return void(keyListUl.innerHTML="<li>暂无 API Key。</li>");apiKeys.forEach((e,t)=>{const s=`${e.substring(0,4)}...${e.substring(e.length-4)}`,o=document.createElement("li");o.innerHTML=`<span>${s}</span><button class="delete-key-btn" data-index="${t}" title="删除">&times;</button>`,keyListUl.appendChild(o)})}    function addKey(){const e=apiKeyInput.value.trim();e&&!apiKeys.includes(e)?(apiKeys.push(e),saveKeysToStorage(),renderKeyList(),updateUIOnKeyChange(),apiKeyInput.value=""):apiKeys.includes(e)&&alert("这个 API Key 已经存在了。")}    function deleteKey(e){apiKeys.splice(e,1),saveKeysToStorage(),renderKeyList(),updateUIOnKeyChange()}    function updateUIOnKeyChange(){0===apiKeys.length?(searchBtn.disabled=!0,searchBtn.textContent="请先设置 API Key"):(searchBtn.disabled=!1,searchBtn.textContent="生成阅读计划")}    // 事件监听器    searchBtn.addEventListener("click",handleSearch);    settingsBtn.addEventListener("click",()=>{settingsModal.style.display="flex"});    closeModalBtn.addEventListener("click",()=>{settingsModal.style.display="none"});    settingsModal.addEventListener("click",e=>{e.target===settingsModal&&(settingsModal.style.display="none")});    addKeyBtn.addEventListener("click",addKey);    apiKeyInput.addEventListener("keyup",e=>{"Enter"===e.key&&addKey()});    keyListUl.addEventListener("click",e=>{if(e.target.classList.contains("delete-key-btn")){const t=parseInt(e.target.dataset.index,10);deleteKey(t)}});    resultsContainer.addEventListener('click', (event) => {        if (event.target.classList.contains('anna-toggle-btn')) {            const dropdown = event.target.nextElementSibling;            if (dropdown && dropdown.classList.contains('mirror-links-dropdown')) {                dropdown.style.display = dropdown.style.display === 'none' ? 'block' : 'none';            }        }    });    // 初始化    loadKeysFromStorage();});