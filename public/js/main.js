document.addEventListener('DOMContentLoaded', () => {    // 配置区域    const PROXY_ENDPOINT = '/proxy';    // DOM元素    const searchBtn = document.getElementById('search-btn');    const queryInput = document.getElementById('query-input');    const resultsContainer = document.getElementById('results-container');    const loadingSpinner = document.getElementById('loading-spinner');    const infoBox = document.getElementById('info-box');    const settingsBtn = document.getElementById('settings-btn');    const settingsModal = document.getElementById('settings-modal');    const closeModalBtn = document.getElementById('close-modal-btn');    const addKeyBtn = document.getElementById('add-key-btn');    const apiKeyInput = document.getElementById('api-key-input');    const keyListUl = document.getElementById('key-list-ul');    let apiKeys = [];    let currentKeyIndex = 0;    // 主处理函数 - 采用并行处理优化性能    async function handleSearch() {        if (apiKeys.length === 0) { /* ... */ return; }        const query = queryInput.value.trim();        if (query === "") { /* ... */ return; }                currentKeyIndex = 0;        infoBox.style.display = 'none';        setLoadingState(true, '智能分析中，请稍候...');        try {            // --- 并行任务开始 ---                        // 任务一：生成阅读计划 (包含三个串行步骤)            const planPromise = (async () => {                setLoadingState(true, '第一步：生成概念计划...');                const initialPlan = await fetchAIResponseWithProxy(buildInitialPrompt(query));                setLoadingState(true, '第二步：核查并优化书单...');                const refinedPlan = await fetchAIResponseWithProxy(buildRefinementPrompt(initialPlan));                setLoadingState(true, '第三步：评估可用性...');                const finalPlan = await fetchAIResponseWithProxy(buildAvailabilityPrompt(refinedPlan));                return finalPlan;            })();            // 任务二：寻找可用资源路径 (独立任务)            const resourcesPromise = fetchAIResponseWithProxy(buildResourceFinderPrompt());            // 等待两个并行任务全部完成            const [finalPlan, resourceList] = await Promise.all([planPromise, resourcesPromise]);            displayResults(finalPlan, resourceList);        } catch (error) {            console.error('发生错误:', error);            displayError(error.message);        } finally {            setLoadingState(false);        }    }    // 结果渲染函数 - 升级以支持 Z-Library 和官网链接    function displayResults(data, resourceList) {        resultsContainer.innerHTML = '';         infoBox.style.display = 'block';        if (!data.planTitle || !Array.isArray(data.books)) { /* ... */ return; }        // ... (添加标题的代码不变)        const planTitleElement = document.createElement('h2');        planTitleElement.className = 'plan-title';        planTitleElement.style.textAlign = 'center';        planTitleElement.style.marginBottom = '20px';        planTitleElement.textContent = data.planTitle;        resultsContainer.appendChild(planTitleElement);        const annaMirrors = resourceList?.anna_archive || [];        const zlibMirrors = resourceList?.z_library || [];        data.books.forEach(book => {            const card = document.createElement('div');            card.className = 'result-card';                        // --- Anna's Archive 链接 ---            const annaOfficialUrl = `https://annas-archive.org/search?q=${encodeURIComponent(book.searchQuery)}`;            const annaLinks = [                { url: annaOfficialUrl, name: "Official Site" },                ...annaMirrors.map(mirror => {                    try { return { url: `${new URL(mirror).origin}/search?q=${encodeURIComponent(book.searchQuery)}`, name: new URL(mirror).hostname }; } catch { return null; }                }).filter(Boolean)            ];            const annaHtml = createDropdownHTML('anna-archive', "Anna's Archive", annaLinks);            // --- Z-Library 链接 ---            const zlibOfficialUrl = `https://singlelogin.re/s/${encodeURIComponent(book.searchQuery)}`;            const zlibLinks = [                { url: zlibOfficialUrl, name: "Official Site" },                ...zlibMirrors.map(mirror => {                    try { return { url: `${new URL(mirror).origin}/s/${encodeURIComponent(book.searchQuery)}`, name: new URL(mirror).hostname }; } catch { return null; }                }).filter(Boolean)            ];            const zlibHtml = createDropdownHTML('z-library', "Z-Library", zlibLinks);            // ... (可用性评估和后备链接部分不变)            let availabilityHtml = '', fallbacksHtml = ''; /* ... */            card.innerHTML = `                <h2>${book.stage}</h2>                <p class="book-title">${book.title} - ${book.author}</p>                <p><strong>书籍简介：</strong>${book.summary}</p>                <p><strong>推荐理由：</strong>${book.reason}</p>                ${availabilityHtml}                <div class="links-container">                    ${annaHtml}                    ${zlibHtml}                    ${fallbacksHtml}                </div>            `;            // 填充可用性评估和后备链接的HTML            if(book.availability){let e="status-medium";"HIGHLY_LIKELY"===book.availability.anna_archive_status?e="status-high":"RARE"===book.availability.anna_archive_status&&(e="status-low"),availabilityHtml=`<div class="availability-section">\n                    <strong>资源可用性评估: </strong><span class="status-tag ${e}">${book.availability.anna_archive_status.replace("_"," ")}</span>\n                    <p class="availability-note">${book.availability.note}</p>\n                </div>`}if(book.availability&&book.availability.fallbacks&&book.availability.fallbacks.length>0){fallbacksHtml+='<div class="fallbacks-section"><strong>备用查找途径:</strong> ';book.availability.fallbacks.forEach(e=>{fallbacksHtml+=`<a href="${e.url}" target="_blank" class="fallback-link">${e.name}</a>`});fallbacksHtml+="</div>"}            card.querySelector('.links-container').insertAdjacentHTML('afterend', fallbacksHtml); // 插入后备            card.querySelector('.book-title').insertAdjacentHTML('afterend', availabilityHtml); // 插入可用性            resultsContainer.appendChild(card);        });    }        // 创建下拉链接的辅助函数    function createDropdownHTML(id, label, links) {        let dropdownHtml = `<div class="mirror-links-dropdown" id="${id}-dropdown" style="display:none;">`;        if (links && links.length > 0) {            links.forEach((link, index) => {                const isOfficial = link.name === "Official Site";                dropdownHtml += `<a href="${link.url}" target="_blank" class="mirror-link ${isOfficial ? 'official-link' : ''}">${link.name} ${isOfficial ? ' (官网)' : ''}</a>`;            });        } else {            dropdownHtml += `<span class="mirror-link-error">未能获取到可用地址。</span>`;        }        dropdownHtml += `</div>`;        return `<div class="links-wrapper"><button class="toggle-btn" data-target="${id}-dropdown">${label}</button>${dropdownHtml}</div>`;    }    // 全新！构建第四步“资源查找”的Prompt (一次性获取所有)    function buildResourceFinderPrompt() {        const instruction = `你是一位精通全球互联网资源访问的专家。你的任务是提供当前最有可能在中国大陆地区可用的 Anna's Archive 和 Z-Library 镜像网站地址列表。规则：1. 返回一个JSON对象，包含两个键: "anna_archive" 和 "z_library"。2. 每个键对应的值是一个包含3到5个URL字符串的数组。3. 这些URL应基于你最新知识库，选择最稳定、最被社群推荐的镜像地址。4. 只提供镜像地址，不要包含官网主站。5. 除了这个JSON对象，绝对不要返回任何其他文字、解释或注释。示例输出:{  "anna_archive": ["https://annas-archive.gs", "https://annas-archive.se"],  "z_library": ["https://z-lib.is", "https://z-lib.id"]}`;        return {            contents: [{                role: "user",                parts: [{ text: instruction }]            }],            generationConfig: { response_mime_type: "application/json" }        };    }        // 事件监听器 - 升级为通用    resultsContainer.addEventListener('click', (event) => {        if (event.target.classList.contains('toggle-btn')) {            const targetId = event.target.dataset.target;            const dropdown = document.getElementById(targetId);            if (dropdown) {                dropdown.style.display = dropdown.style.display === 'none' ? 'block' : 'none';            }        }    });    // --- 以下是其他所有未变动或微调的辅助函数 ---    function buildInitialPrompt(e){const t=`你是一个博学且专业的阅读计划助手。你的任务是根据用户的需求，为其推荐一个结构化的阅读计划。你必须严格按照以下JSON格式返回你的推荐，除了这个JSON对象外，不要包含任何其他文字、解释或注释。JSON格式定义如下：{"planTitle": "关于用户需求的阅读计划标题", "books": [{"stage": "第一阶段：入门与概览", "title": "书籍A的完整标题", "author": "作者A", "summary": "书籍A的简要介绍。", "reason": "推荐这本书的理由。", "searchQuery": "作者A 书籍A的完整标题"}]}`;return{contents:[{role:"user",parts:[{text:t},{text:"用户需求如下："},{text:e}]}],generationConfig:{response_mime_type:"application/json"}}}    function buildRefinementPrompt(e){const t=`你是一个严谨的图书信息事实核查员。你的任务是接收一个JSON格式的初步阅读计划，并对其进行审查和优化，然后返回一个格式完全相同但信息更精准的JSON对象。审查规则：1. 核对作者：修正为该书最广为人知、最权威的作者。2. 优化书名：使用最常见、最容易被搜索到的版本。3. 保持结构：不要更改 "stage", "summary", "reason" 字段。4. 更新searchQuery：根据你修正后的权威作者和书名，生成一个最优化的新 "searchQuery" 字段。除了修正后的JSON对象，绝对不要返回任何其他文字。`,s=JSON.stringify(e,null,2);return{contents:[{role:"user",parts:[{text:t},{text:"这是需要你审查和优化的初步阅读计划JSON："},{text:s}]}],generationConfig:{response_mime_type:"application/json"}}}    function buildAvailabilityPrompt(e){const t=`你是一个资深的数字资源馆员。你的任务是接收一个信息精准的JSON阅读计划，并为其扩充“可用性评估”信息，然后返回一个结构增强的JSON对象。增强规则：1. 为每本书添加 "availability" 字段，包含 "anna_archive_status" ("HIGHLY_LIKELY" | "UNCERTAIN" | "RARE"), "note" (简短说明), "fallbacks" (备用搜索链接数组)。2. 根据书籍知名度评估可能性。3. 生成至少1-2个后备链接 (Google Books, Open Library等)。4. 保持原始数据不变。5. 严格返回JSON。增强后的book对象结构示例：{"stage": "...", "availability": {"anna_archive_status": "HIGHLY_LIKELY", "note": "...", "fallbacks": [{"name": "Google Books", "url": "..."}]}}`,s=JSON.stringify(e,null,2);return{contents:[{role:"user",parts:[{text:t},{text:"这是需要你评估和增强的阅读计划JSON："},{text:s}]}],generationConfig:{response_mime_type:"application/json"}}}    async function fetchAIResponseWithProxy(e){if(currentKeyIndex>=apiKeys.length)throw new Error("您提供的所有API Key都已尝试过或额度耗尽。");const t=apiKeys[currentKeyIndex];try{const s=await fetch(PROXY_ENDPOINT,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({apiKey:t,body:e})});if(429===s.status)return console.warn(`API Key ${t.substring(0,4)}... 遭遇限制，尝试下一个Key...`),currentKeyIndex++,fetchAIResponseWithProxy(e);const o=await s.json();if(!s.ok||!o.candidates){const n=o.error?o.error.message:"未知API错误";throw new Error(`API 请求失败: ${n||"无法获取有效响应"}`)}const a=o.candidates[0].content.parts[0].text;return JSON.parse(extractJson(a))}catch(r){if(r instanceof TypeError)return console.warn("网络请求失败，尝试下一个Key..."),currentKeyIndex++,fetchAIResponseWithProxy(e);if(r instanceof SyntaxError)throw new Error("AI返回的数据格式不正确，无法解析为JSON。");throw r}}    function extractJson(e){const t=e.match(/```json\s*([\s\S]*?)\s*```/);return t&&t[1]?t[1]:e}    function displayError(e){setLoadingState(!1),resultsContainer.innerHTML=`<div class="error-message"><h3>糟糕，出错了！</h3><p>${e}</p><p>请检查你的网络连接和API Key配置，然后重试。</p></div>`}    function setLoadingState(e,t){searchBtn.disabled=e,e?(searchBtn.textContent=t,resultsContainer.innerHTML="",loadingSpinner.style.display="block",resultsContainer.appendChild(loadingSpinner)):(searchBtn.textContent="生成阅读计划",loadingSpinner.style.display="none")}    function loadKeysFromStorage(){const e=localStorage.getItem("geminiApiKeys");apiKeys=e?JSON.parse(e):[],updateUIOnKeyChange(),renderKeyList()}    function saveKeysToStorage(){localStorage.setItem("geminiApiKeys",JSON.stringify(apiKeys))}    function renderKeyList(){if(keyListUl.innerHTML="",0===apiKeys.length)return void(keyListUl.innerHTML="<li>暂无 API Key。</li>");apiKeys.forEach((e,t)=>{const s=`${e.substring(0,4)}...${e.substring(e.length-4)}`,o=document.createElement("li");o.innerHTML=`<span>${s}</span><button class="delete-key-btn" data-index="${t}" title="删除">&times;</button>`,keyListUl.appendChild(o)})}    function addKey(){const e=apiKeyInput.value.trim();e&&!apiKeys.includes(e)?(apiKeys.push(e),saveKeysToStorage(),renderKeyList(),updateUIOnKeyChange(),apiKeyInput.value=""):apiKeys.includes(e)&&alert("这个 API Key 已经存在了。")}    function deleteKey(e){apiKeys.splice(e,1),saveKeysToStorage(),renderKeyList(),updateUIOnKeyChange()}    function updateUIOnKeyChange(){0===apiKeys.length?(searchBtn.disabled=!0,searchBtn.textContent="请先设置 API Key"):(searchBtn.disabled=!1,searchBtn.textContent="生成阅读计划")}    searchBtn.addEventListener("click",handleSearch),settingsBtn.addEventListener("click",()=>{settingsModal.style.display="flex"}),closeModalBtn.addEventListener("click",()=>{settingsModal.style.display="none"}),settingsModal.addEventListener("click",e=>{e.target===settingsModal&&(settingsModal.style.display="none")}),addKeyBtn.addEventListener("click",addKey),apiKeyInput.addEventListener("keyup",e=>{"Enter"===e.key&&addKey()}),keyListUl.addEventListener("click",e=>{if(e.target.classList.contains("delete-key-btn")){const t=parseInt(e.target.dataset.index,10);deleteKey(t)}});    loadKeysFromStorage();});