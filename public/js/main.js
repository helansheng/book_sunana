document.addEventListener('DOMContentLoaded', () => {    // =======================================================    // 配置区域    // =======================================================    const PROXY_ENDPOINT = '/proxy';    const API_TIMEOUT_MS = 45000; // 45秒API请求超时    // =======================================================    // DOM元素获取    // =======================================================    const searchBtn = document.getElementById('search-btn');    const queryInput = document.getElementById('query-input');    const resultsContainer = document.getElementById('results-container');    const loadingSpinner = document.getElementById('loading-spinner');    const infoBox = document.getElementById('info-box');    const settingsBtn = document.getElementById('settings-btn');    const settingsModal = document.getElementById('settings-modal');    const closeModalBtn = document.getElementById('close-modal-btn');    const addKeyBtn = document.getElementById('add-key-btn');    const apiKeyInput = document.getElementById('api-key-input');    const keyListUl = document.getElementById('key-list-ul');    let apiKeys = [];    let currentKeyIndex = 0;    // =======================================================    // 主处理函数    // =======================================================    async function handleSearch() {        if (apiKeys.length === 0) {            alert("请点击右上角的设置按钮 ⚙️ 添加您的 Google Gemini API Key。");            return;        }        const query = queryInput.value.trim();        if (query === "") {            alert("请输入您的阅读需求！");            return;        }                currentKeyIndex = 0;        infoBox.style.display = 'none';        setLoadingState(true, '智能分析中，请稍候...');        try {            const planPromise = (async () => {                setLoadingState(true, '第一步：生成概念计划...');                const initialPlan = await fetchAIResponseWithProxy(buildInitialPrompt(query));                setLoadingState(true, '第二步：核查并优化书单...');                const refinedPlan = await fetchAIResponseWithProxy(buildRefinementPrompt(initialPlan));                setLoadingState(true, '第三步：评估可用性...');                const finalPlan = await fetchAIResponseWithProxy(buildAvailabilityPrompt(refinedPlan));                return finalPlan;            })();            const resourcesPromise = fetchAIResponseWithProxy(buildResourceFinderPrompt());                        const [finalPlan, resourceList] = await Promise.all([planPromise, resourcesPromise]);                        displayResults(finalPlan, resourceList);        } catch (error) {            console.error('最终错误:', error);            displayError(error.message);        } finally {            setLoadingState(false);        }    }    // =======================================================    // 带有超时和健壮重试机制的API调用函数    // =======================================================    async function fetchAIResponseWithProxy(promptBody) {        if (currentKeyIndex >= apiKeys.length) {            throw new Error("您提供的所有API Key都已尝试过或均无效/超时。");        }        const currentKey = apiKeys[currentKeyIndex];                const controller = new AbortController();        const timeoutId = setTimeout(() => {            console.warn(`API 请求超时 (${API_TIMEOUT_MS / 1000}秒)，中止请求...`);            controller.abort();        }, API_TIMEOUT_MS);        try {            const response = await fetch(PROXY_ENDPOINT, {                method: 'POST',                headers: { 'Content-Type': 'application/json' },                body: JSON.stringify({ apiKey: currentKey, body: promptBody }),                signal: controller.signal            });            clearTimeout(timeoutId);            if (!response.ok) {                const errorData = await response.json().catch(() => ({}));                const errorMessage = errorData.error?.message || `服务器返回错误，状态码: ${response.status}`;                throw new Error(errorMessage);            }                        const data = await response.json();                        if (!data.candidates || data.candidates.length === 0) {                throw new Error("API响应格式不正确，缺少'candidates'。");            }            const rawText = data.candidates[0].content.parts[0].text;            return JSON.parse(extractJson(rawText));        } catch (error) {            clearTimeout(timeoutId);            if (error.name === 'AbortError' || error instanceof TypeError || error.message.includes("服务器返回错误")) {                 console.warn(`Key ${currentKey.substring(0,4)}... 遭遇网络或服务器错误，尝试下一个Key...`, error.message);                 currentKeyIndex++;                 return fetchAIResponseWithProxy(promptBody);            }            if (error instanceof SyntaxError) {                throw new Error("AI返回的数据格式不正确，无法解析为JSON。");            }            throw error;        }    }    // =======================================================    // 结果渲染函数    // =======================================================    function displayResults(data, resourceList) {        resultsContainer.innerHTML = '';        infoBox.style.display = 'block';        if (!data.planTitle || !Array.isArray(data.books)) {            displayError("AI返回的阅读计划格式不正确，无法解析。");            return;        }        const planTitleElement = document.createElement('h2');        planTitleElement.className = 'plan-title';        planTitleElement.style.textAlign = 'center';        planTitleElement.style.marginBottom = '20px';        planTitleElement.textContent = data.planTitle;        resultsContainer.appendChild(planTitleElement);        const annaMirrors = resourceList?.anna_archive || [];        const zlibMirrors = resourceList?.z_library || [];        data.books.forEach((book, index) => {            const card = document.createElement('div');            card.className = 'result-card';                        const searchQuery = encodeURIComponent(book.searchQuery);            const annaOfficialUrl = `https://annas-archive.org/search?q=${searchQuery}`;            const annaLinks = [                { url: annaOfficialUrl, name: "Official Site" },                ...annaMirrors.map(mirror => {                    try { return { url: `${new URL(mirror).origin}/search?q=${searchQuery}`, name: new URL(mirror).hostname }; } catch { return null; }                }).filter(Boolean)            ];            const annaHtml = createDropdownHTML(`anna-archive-${index}`, "Anna's Archive", annaLinks);            const zlibOfficialUrl = `https://singlelogin.re/s/${searchQuery}`;            const zlibLinks = [                { url: zlibOfficialUrl, name: "Official Site" },                ...zlibMirrors.map(mirror => {                    try { return { url: `${new URL(mirror).origin}/s?q=${searchQuery}`, name: new URL(mirror).hostname }; } catch { return null; }                }).filter(Boolean)            ];            const zlibHtml = createDropdownHTML(`z-library-${index}`, "Z-Library", zlibLinks);            let availabilityHtml = '';            if (book.availability) {                let statusClass = 'status-medium';                if (book.availability.anna_archive_status === 'HIGHLY_LIKELY') statusClass = 'status-high';                else if (book.availability.anna_archive_status === 'RARE') statusClass = 'status-low';                                availabilityHtml = `<div class="availability-section"><strong>资源可用性评估: </strong><span class="status-tag ${statusClass}">${book.availability.anna_archive_status.replace(/_/g, ' ')}</span><p class="availability-note">${book.availability.note}</p></div>`;            }            let fallbacksHtml = '';            if (book.availability && book.availability.fallbacks && book.availability.fallbacks.length > 0) {                fallbacksHtml += '<div class="fallbacks-section"><strong>备用查找途径:</strong> ';                book.availability.fallbacks.forEach(link => {                    if (link.name === 'ManyBooks' && link.availability_note) {                        fallbacksHtml += `<div class="fallback-item-with-note"><a href="${link.url}" target="_blank" class="fallback-link">${link.name}</a><span class="fallback-note">(${link.availability_note})</span></div>`;                    } else {                        fallbacksHtml += `<a href="${link.url}" target="_blank" class="fallback-link">${link.name}</a>`;                    }                });                fallbacksHtml += '</div>';            }                        card.innerHTML = `                <h2>${book.stage}</h2>                <p class="book-title">${book.title} - ${book.author}</p>                ${availabilityHtml}                <p><strong>书籍简介：</strong>${book.summary}</p>                <p><strong>推荐理由：</strong>${book.reason}</p>                <div class="links-container">                    ${annaHtml}                    ${zlibHtml}                    ${fallbacksHtml}                </div>            `;            resultsContainer.appendChild(card);        });    }    function createDropdownHTML(id, label, links) {        let dropdownHtml = `<div class="mirror-links-dropdown" id="${id}" style="display:none;">`;        if (links && links.length > 0) {            links.forEach(link => {                const isOfficial = link.name === "Official Site";                dropdownHtml += `<a href="${link.url}" target="_blank" class="mirror-link ${isOfficial ? 'official-link' : ''}">${link.name} ${isOfficial ? ' (官网)' : ''}</a>`;            });        } else {            dropdownHtml += `<span class="mirror-link-error">未能获取到可用地址。</span>`;        }        dropdownHtml += `</div>`;        return `<div class="links-wrapper"><button class="toggle-btn" data-target="${id}">${label}</button>${dropdownHtml}</div>`;    }    // =======================================================    // AI Prompt 构建函数    // =======================================================    function buildInitialPrompt(userQuery) {        const instruction = `你是一个博学且专业的阅读计划助手。你的任务是根据用户的需求，为其推荐一个结构化的阅读计划。你必须严格按照以下JSON格式返回你的推荐，除了这个JSON对象外，不要包含任何其他文字、解释或注释。JSON格式定义如下：{"planTitle": "关于用户需求的阅读计划标题", "books": [{"stage": "第一阶段：入门与概览", "title": "书籍A的完整标题", "author": "作者A", "summary": "书籍A的简要介绍。", "reason": "推荐这本书的理由。", "searchQuery": "作者A 书籍A的完整标题"}]}`;        return {            contents: [{ role: "user", parts: [{ text: instruction }, { text: "用户需求如下：" }, { text: userQuery }] }],            generationConfig: { response_mime_type: "application/json" }        };    }    function buildRefinementPrompt(initialPlan) {        const instruction = `你是一个严谨的图书信息事实核查员。你的任务是接收一个JSON格式的初步阅读计划，并对其进行审查和优化，然后返回一个格式完全相同但信息更精准的JSON对象。审查规则：1. 核对作者：修正为该书最广为人知、最权威的作者。2. 优化书名：使用最常见、最容易被搜索到的版本。3. 保持结构：不要更改 "stage", "summary", "reason" 字段。4. 更新searchQuery：根据你修正后的权威作者和书名，生成一个最优化的新 "searchQuery" 字段。除了修正后的JSON对象，绝对不要返回任何其他文字。`;        const planString = JSON.stringify(initialPlan, null, 2);        return {            contents: [{ role: "user", parts: [{ text: instruction }, { text: "这是需要你审查和优化的初步阅读计划JSON：" }, { text: planString }] }],            generationConfig: { response_mime_type: "application/json" }        };    }    function buildAvailabilityPrompt(refinedPlan) {        const instruction = `你是一个资深的数字资源馆员。你的任务是接收一个信息精准的JSON阅读计划，并为其扩充“可用性评估”信息。增强规则：1. 为每本书添加 "availability" 字段，包含 "anna_archive_status" ("HIGHLY_LIKELY" | "UNCERTAIN" | "RARE"), "note", "fallbacks" 数组。2. "fallbacks" 必须包含 Google Books 和 Open Library 的链接。3. **特别针对 manybooks.net**：构建其搜索URL，并添加 "availability_note" 字段评估找到的可能性（例如，“该网站以公版英文书为主，找到此中文现代书籍的可能性较低。”）。4. 严格返回JSON。`;        const planString = JSON.stringify(refinedPlan, null, 2);        return {            contents: [{ role: "user", parts: [{ text: instruction }, { text: "这是需要你评估和增强的阅读计划JSON：" }, { text: planString }] }],            generationConfig: { response_mime_type: "application/json" }        };    }    function buildResourceFinderPrompt() {        const instruction = `你是一位精通全球互联网资源访问的专家，且将用户安全置于首位。你的任务是提供当前最有可能在中国大陆地区可用的 Anna's Archive 和 Z-Library 镜像网站地址列表。CRITICAL SAFETY RULE: 绝对禁止提供任何已知托管成人内容、恶意软件、赌博或非法信息的网站。你的首要职责是确保所有链接都是安全且仅与图书下载相关的。规则：1. 返回一个JSON对象，包含两个键: "anna_archive" 和 "z_library"。2. 每个键的值是一个包含2到4个URL字符串的数组。3. 只提供镜像地址。4. 除了JSON对象，不返回任何其他文字。`;        return {            contents: [{ role: "user", parts: [{ text: instruction }] }],            generationConfig: { response_mime_type: "application/json" }        };    }    // =======================================================    // 辅助函数    // =======================================================    function extractJson(rawText) { const match = rawText.match(/```json\s*([\s\S]*?)\s*```/); return match && match[1] ? match[1] : rawText; }        function displayError(message) {        setLoadingState(false);        resultsContainer.innerHTML = `<div class="error-message"><h3>糟糕，出错了！</h3><p>${message}</p><p>请检查你的网络连接和API Key配置，然后重试。</p></div>`;    }        function setLoadingState(isLoading, text) {        searchBtn.disabled = isLoading;        if (isLoading) {            searchBtn.textContent = text || '思考中...';            resultsContainer.innerHTML = '';            loadingSpinner.style.display = 'block';            resultsContainer.appendChild(loadingSpinner);        } else {            searchBtn.textContent = '生成阅读计划';            loadingSpinner.style.display = 'none';        }    }    function loadKeysFromStorage() {        const storedKeys = localStorage.getItem('geminiApiKeys');        apiKeys = storedKeys ? JSON.parse(storedKeys) : [];        updateUIOnKeyChange();        renderKeyList();    }    function saveKeysToStorage() { localStorage.setItem('geminiApiKeys', JSON.stringify(apiKeys)); }    function renderKeyList() {        keyListUl.innerHTML = "";        if (apiKeys.length === 0) { keyListUl.innerHTML = "<li>暂无 API Key。</li>"; return; }        apiKeys.forEach((key, index) => {            const maskedKey = `${key.substring(0, 4)}...${key.substring(key.length - 4)}`;            const li = document.createElement('li');            li.innerHTML = `<span>${maskedKey}</span><button class="delete-key-btn" data-index="${index}" title="删除">&times;</button>`;            keyListUl.appendChild(li);        });    }    function addKey() {        const key = apiKeyInput.value.trim();        if (key && !apiKeys.includes(key)) {            apiKeys.push(key);            saveKeysToStorage();            renderKeyList();            updateUIOnKeyChange();            apiKeyInput.value = "";        } else if (apiKeys.includes(key)) {            alert("这个 API Key 已经存在了。");        }    }    function deleteKey(index) {        apiKeys.splice(index, 1);        saveKeysToStorage();        renderKeyList();        updateUIOnKeyChange();    }    function updateUIOnKeyChange() {        if (apiKeys.length === 0) {            searchBtn.disabled = true;            searchBtn.textContent = '请先设置 API Key';        } else {            searchBtn.disabled = false;            searchBtn.textContent = '生成阅读计划';        }    }    // =======================================================    // 事件监听器    // =======================================================    searchBtn.addEventListener("click", handleSearch);    settingsBtn.addEventListener("click", () => { settingsModal.style.display = "flex" });    closeModalBtn.addEventListener("click", () => { settingsModal.style.display = "none" });    settingsModal.addEventListener("click", e => { e.target === settingsModal && (settingsModal.style.display = "none") });    addKeyBtn.addEventListener("click", addKey);    apiKeyInput.addEventListener("keyup", e => { "Enter" === e.key && addKey() });    keyListUl.addEventListener("click", e => { if (e.target.classList.contains("delete-key-btn")) { const t = parseInt(e.target.dataset.index, 10); deleteKey(t) } });        resultsContainer.addEventListener('click', (event) => {        if (event.target.classList.contains('toggle-btn')) {            const targetId = event.target.dataset.target;            const dropdown = document.getElementById(targetId);            if (dropdown) {                dropdown.style.display = dropdown.style.display === 'none' ? 'block' : 'none';            }        }    });    // =======================================================    // 初始化    // =======================================================    loadKeysFromStorage();});