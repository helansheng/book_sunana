document.addEventListener('DOMContentLoaded', () => {    // =================================================================    // ======================  配置区域  ===============================    // =================================================================        // API代理的端点，现在我们请求自己的代理，而不是直接请求Google    const PROXY_ENDPOINT = '/proxy';    // =================================================================    // ===================  DOM 元素获取  =============================    // =================================================================    const searchBtn = document.getElementById('search-btn');    const queryInput = document.getElementById('query-input');    const resultsContainer = document.getElementById('results-container');    const loadingSpinner = document.getElementById('loading-spinner');        // 设置弹窗相关元素    const settingsBtn = document.getElementById('settings-btn');    const settingsModal = document.getElementById('settings-modal');    const closeModalBtn = document.getElementById('close-modal-btn');    const addKeyBtn = document.getElementById('add-key-btn');    const apiKeyInput = document.getElementById('api-key-input');    const keyListUl = document.getElementById('key-list-ul');    // =================================================================    // ===================  API Key 管理逻辑  =========================    // =================================================================        let apiKeys = []; // 内存中的API Key列表    let currentKeyIndex = 0;    // 从 localStorage 加载 Keys    function loadKeysFromStorage() {        const storedKeys = localStorage.getItem('geminiApiKeys');        apiKeys = storedKeys ? JSON.parse(storedKeys) : [];        updateUIOnKeyChange();        renderKeyList();    }    // 保存 Keys 到 localStorage    function saveKeysToStorage() {        localStorage.setItem('geminiApiKeys', JSON.stringify(apiKeys));    }    // 渲染 Key 列表到弹窗    function renderKeyList() {        keyListUl.innerHTML = '';        if (apiKeys.length === 0) {            keyListUl.innerHTML = '<li>暂无 API Key。</li>';            return;        }        apiKeys.forEach((key, index) => {            const maskedKey = `${key.substring(0, 4)}...${key.substring(key.length - 4)}`;            const li = document.createElement('li');            li.innerHTML = `                <span>${maskedKey}</span>                <button class="delete-key-btn" data-index="${index}" title="删除">&times;</button>            `;            keyListUl.appendChild(li);        });    }    // 添加 Key    function addKey() {        const key = apiKeyInput.value.trim();        if (key && !apiKeys.includes(key)) {            apiKeys.push(key);            saveKeysToStorage();            renderKeyList();            updateUIOnKeyChange();            apiKeyInput.value = '';        } else if (apiKeys.includes(key)) {            alert('这个 API Key 已经存在了。');        }    }    // 删除 Key    function deleteKey(index) {        apiKeys.splice(index, 1);        saveKeysToStorage();        renderKeyList();        updateUIOnKeyChange();    }        // 根据是否有Key更新主界面    function updateUIOnKeyChange() {        if (apiKeys.length === 0) {            searchBtn.disabled = true;            searchBtn.textContent = '请先设置 API Key';        } else {            searchBtn.disabled = false;            searchBtn.textContent = '生成阅读计划';        }    }    // =================================================================    // ===================  主应用逻辑  ================================    // =================================================================    async function handleSearch() {        if (apiKeys.length === 0) {            alert("请点击右上角的设置按钮 ⚙️ 添加您的 Google Gemini API Key。");            return;        }        const query = queryInput.value.trim();        if (query === "") {            alert("请输入您的阅读需求！");            return;        }                currentKeyIndex = 0; // 每次新的搜索都从第一个key开始        setLoadingState(true);        try {            const prompt = buildPrompt(query);            const aiResponseText = await fetchAIResponseWithProxy(prompt);            const jsonString = extractJson(aiResponseText);            const readingPlan = JSON.parse(jsonString);            displayResults(readingPlan);        } catch (error) {            console.error('发生错误:', error);            displayError(error.message);        } finally {            setLoadingState(false);        }    }    function setLoadingState(isLoading) {        if (isLoading) {            searchBtn.disabled = true;            searchBtn.textContent = '思考中...';            resultsContainer.innerHTML = '';            loadingSpinner.style.display = 'block';            resultsContainer.appendChild(loadingSpinner);        } else {            loadingSpinner.style.display = 'none';            searchBtn.disabled = false;            searchBtn.textContent = '生成阅读计划';        }    }    function buildPrompt(userQuery) {        // ... (此函数内容与上一版完全相同，无需修改)        const instruction = `你是一个博学且专业的阅读计划助手。你的任务是根据用户的需求，为其推荐一个结构化的阅读计划。你必须严格按照以下JSON格式返回你的推荐，除了这个JSON对象外，不要包含任何其他文字、解释或注释。JSON格式定义如下：{  "planTitle": "关于用户需求的阅读计划标题",  "books": [    {      "stage": "第一阶段：入门与概览",      "title": "书籍A的完整标题",      "author": "作者A",      "summary": "书籍A的简要介绍，说明其核心内容和特点。",      "reason": "推荐这本书作为第一阶段阅读的理由，比如为什么它适合入门。",      "searchQuery": "作者A 书籍A的完整标题"    }  ]}`;        return {            "contents": [{"parts": [{"text": instruction}, {"text": "用户需求如下："}, {"text": userQuery}]}],            "generationConfig": {"response_mime_type": "application/json"}        };    }    async function fetchAIResponseWithProxy(promptBody) {        if (currentKeyIndex >= apiKeys.length) {            throw new Error("您提供的所有API Key都已尝试过或额度耗尽。");        }        const currentKey = apiKeys[currentKeyIndex];        try {            const response = await fetch(PROXY_ENDPOINT, {                method: 'POST',                headers: { 'Content-Type': 'application/json' },                body: JSON.stringify({                    apiKey: currentKey, // 把当前要用的key发给代理                    body: promptBody     // 把要发给Google的请求体发给代理                })            });            const data = await response.json();            if (response.status === 429) {                console.warn(`API Key ${currentKey.substring(0,4)}... 遭遇速率或额度限制，尝试下一个Key...`);                currentKeyIndex++;                return fetchAIResponseWithProxy(promptBody);            }            if (!response.ok || !data.candidates) {                 const errorMessage = data.error ? data.error.message : "未知API错误";                 throw new Error(`API 请求失败: ${errorMessage}`);            }            return data.candidates[0].content.parts[0].text;        } catch (error) {            if (error instanceof TypeError) {                 console.warn(`网络请求失败，尝试下一个Key...`);                 currentKeyIndex++;                 return fetchAIResponseWithProxy(promptBody);            }            throw error;        }    }    // displayResults, extractJson, displayError 函数与上一版完全相同，无需修改    function displayResults(data) { /* ... no change ... */ }    function extractJson(rawText) { /* ... no change ... */ }    function displayError(message) { /* ... no change ... */ }    // 为了完整性，我把它们也附上    function displayResults(data){resultsContainer.innerHTML="",!data.planTitle||!Array.isArray(data.books)?displayError("AI返回的数据格式不正确，无法解析。"):(()=>{const e=document.createElement("h2");e.className="plan-title",e.style.textAlign="center",e.style.marginBottom="20px",e.textContent=data.planTitle,resultsContainer.appendChild(e),data.books.forEach(t=>{const a=`https://tw.annas-archive.org/search?q=${encodeURIComponent(t.searchQuery)}`,s=document.createElement("div");s.className="result-card",s.innerHTML=`\n                <h2>${t.stage}</h2>\n                <p class="book-title">${t.title} - ${t.author}</p>\n                <p><strong>书籍简介：</strong>${t.summary}</p>\n                <p><strong>推荐理由：</strong>${t.reason}</p>\n                <a href="${a}" target="_blank" class="download-link">在 Anna's Archive 中查找</a>\n            `,resultsContainer.appendChild(s)})})()}function extractJson(e){const t=e.match(/```json\s*([\s\S]*?)\s*```/);return t&&t[1]?t[1]:e}function displayError(e){resultsContainer.innerHTML="";const t=document.createElement("div");t.className="error-message",t.innerHTML=`\n            <h3>糟糕，出错了！</h3>\n            <p>${e}</p>\n            <p>请检查你的网络连接和API Key配置，然后重试。</p>\n        `,resultsContainer.appendChild(t)}    // =================================================================    // ===================  事件监听器  ================================    // =================================================================        // 主搜索按钮    searchBtn.addEventListener('click', handleSearch);    // 打开设置弹窗    settingsBtn.addEventListener('click', () => {        settingsModal.style.display = 'flex';    });    // 关闭设置弹窗    closeModalBtn.addEventListener('click', () => {        settingsModal.style.display = 'none';    });    // 点击弹窗外部关闭    settingsModal.addEventListener('click', (event) => {        if (event.target === settingsModal) {            settingsModal.style.display = 'none';        }    });    // 添加 Key 按钮    addKeyBtn.addEventListener('click', addKey);    apiKeyInput.addEventListener('keyup', (event) => {        if (event.key === 'Enter') {            addKey();        }    });    // 删除 Key (事件委托)    keyListUl.addEventListener('click', (event) => {        if (event.target.classList.contains('delete-key-btn')) {            const index = parseInt(event.target.dataset.index, 10);            deleteKey(index);        }    });    // =================================================================    // ===================  初始化  ====================================    // =================================================================    loadKeysFromStorage();});