document.addEventListener('DOMContentLoaded', () => {    // =======================================================    // 配置区域    // =======================================================    const PROXY_ENDPOINT = '/proxy';    const API_TIMEOUT_MS = 60000; // 延长超时至60秒，应对复杂的单次请求    // =======================================================    // DOM元素获取    // =======================================================    const searchBtn = document.getElementById('search-btn');    const queryInput = document.getElementById('query-input');    const resultsContainer = document.getElementById('results-container');    const loadingSpinner = document.getElementById('loading-spinner');    const infoBox = document.getElementById('info-box');    const settingsBtn = document.getElementById('settings-btn');    const settingsModal = document.getElementById('settings-modal');    const closeModalBtn = document.getElementById('close-modal-btn');    const addKeyBtn = document.getElementById('add-key-btn');    const apiKeyInput = document.getElementById('api-key-input');    const keyListUl = document.getElementById('key-list-ul');    let apiKeys = [];    let currentKeyIndex = 0;    // =======================================================    // 主处理函数 (重构为单次API调用)    // =======================================================    async function handleSearch() {        if (apiKeys.length === 0) { alert("请先设置 API Key。"); return; }        const query = queryInput.value.trim();        if (query === "") { alert("请输入您的阅读需求！"); return; }                currentKeyIndex = 0;        infoBox.style.display = 'none';        setLoadingState(true, '正在生成全方位阅读报告...');        try {            const finalReport = await fetchAIResponseWithProxy(buildUltimatePrompt(query));            displayResults(finalReport);        } catch (error) {            console.error('最终错误:', error);            displayError(error.message);        } finally {            setLoadingState(false);        }    }    // =======================================================    // 终极的、唯一的AI Prompt构建函数    // =======================================================    function buildUltimatePrompt(userQuery) {        const instruction = `你是一个全能的、严谨的图书情报专家。你的任务是根据用户的单一请求，一次性生成一个包含完整阅读计划、资源可用性和访问路径的、高度结构化的JSON报告。**CRITICAL SAFETY RULE**: 你必须严格审查你提供的每一个URL。绝对禁止 (ABSOLUTELY PROHIBIT) 提供任何已知托管成人内容、恶意软件、赌博或任何非法信息的网站。你的首要职责是确保所有链接都是安全且仅与图书下载相关的。**最终JSON报告的结构必须如下：**{  "reading_plan": {    "planTitle": "关于用户需求的阅读计划标题",    "books": [      {        "stage": "阶段描述",        "title": "经过事实核查的、最权威的书名",        "author": "经过事实核查的、最权威的作者",        "language": "zh" | "en" | "other", // 智能判断书籍的主要语言        "summary": "书籍简介",        "reason": "推荐理由",        "searchQuery": "最优化的搜索关键词",        "availability": {          "anna_archive_status": "HIGHLY_LIKELY" | "UNCERTAIN" | "RARE",          "note": "关于资源可用性的简短说明",          "fallbacks": [            {              "name": "Google Books",              "url": "..."            },            {              "name": "Open Library",              "url": "..."            },            // manybooks.net 的智能逻辑:            // - 如果 language 是 "en"，则提供 manybooks.net 的搜索链接。            // - 如果 language 是 "zh" 或 "other"，则不应包含 manybooks.net 的条目。            {              "name": "ManyBooks",              "url": "https://manybooks.net/search-book?search=..."            }          ]        }      }    ]  },  "resource_access": {    "anna_archive": ["安全的镜像URL数组"],    "z_library": ["安全的镜像URL数组"]  }}**执行指令:**1.  **阅读计划 (reading_plan)**: 创建一个包含3-5本书的结构化阅读计划。2.  **事实核查**: 在生成计划时，直接使用最权威的书名和作者。3.  **语言判断**: 准确判断每本书的语言。4.  **可用性评估 (availability)**: 像之前的指令一样，评估资源情况并生成后备链接。5.  **ManyBooks 智能逻辑**: 严格遵守上述关于 manybooks.net 的语言判断规则。6.  **资源访问 (resource_access)**: 提供经过安全审查的 Anna's Archive 和 Z-Library 的可用镜像列表。7.  **严格的单一JSON输出**: 你的整个回答必须是且仅是这一个符合上述结构的JSON对象。`;        return {            contents: [{                role: "user",                parts: [                    { text: instruction },                    { text: "这是用户的原始阅读需求：" },                    { text: userQuery }                ]            }],            generationConfig: { response_mime_type: "application/json" }        };    }    // =======================================================    // 结果渲染函数 (重构以适应新的单一JSON结构)    // =======================================================    function displayResults(report) {        resultsContainer.innerHTML = '';        infoBox.style.display = 'block';        const data = report?.reading_plan;        const resourceList = report?.resource_access;        if (!data || !data.planTitle || !Array.isArray(data.books) || !resourceList) {            displayError("AI返回的报告结构不完整，无法解析。");            return;        }        const planTitleElement = document.createElement('h2');        planTitleElement.className = 'plan-title';        planTitleElement.style.textAlign = 'center';        planTitleElement.style.marginBottom = '20px';        planTitleElement.textContent = data.planTitle;        resultsContainer.appendChild(planTitleElement);        const annaMirrors = resourceList.anna_archive || [];        const zlibMirrors = resourceList.z_library || [];        data.books.forEach((book, index) => {            const card = document.createElement('div');            card.className = 'result-card';                        const searchQuery = encodeURIComponent(book.searchQuery);            const annaOfficialUrl = `https://annas-archive.org/search?q=${searchQuery}`;            const annaLinks = [{ url: annaOfficialUrl, name: "Official Site" }, ...annaMirrors.map(m => ({ url: `${m}/search?q=${searchQuery}`, name: new URL(m).hostname })).filter(Boolean)];            const annaHtml = createDropdownHTML(`anna-archive-${index}`, "Anna's Archive", annaLinks);            const zlibOfficialUrl = `https://singlelogin.re/s/${searchQuery}`;            const zlibLinks = [{ url: zlibOfficialUrl, name: "Official Site" }, ...zlibMirrors.map(m => ({ url: `${m}/s?q=${searchQuery}`, name: new URL(m).hostname })).filter(Boolean)];            const zlibHtml = createDropdownHTML(`z-library-${index}`, "Z-Library", zlibLinks);            let availabilityHtml = '', fallbacksHtml = '';            if (book.availability) {                let statusClass = 'status-medium';                if (book.availability.anna_archive_status === 'HIGHLY_LIKELY') statusClass = 'status-high';                else if (book.availability.anna_archive_status === 'RARE') statusClass = 'status-low';                availabilityHtml = `<div class="availability-section"><strong>资源可用性评估: </strong><span class="status-tag ${statusClass}">${book.availability.anna_archive_status.replace(/_/g, ' ')}</span><p class="availability-note">${book.availability.note}</p></div>`;            }            if (book.availability && book.availability.fallbacks && book.availability.fallbacks.length > 0) {                fallbacksHtml += '<div class="fallbacks-section"><strong>备用查找途径:</strong> ';                book.availability.fallbacks.forEach(link => {                    if (link.name === 'ManyBooks' && link.availability_note) {                        fallbacksHtml += `<div class="fallback-item-with-note"><a href="${link.url}" target="_blank" class="fallback-link">${link.name}</a><span class="fallback-note">(${link.availability_note})</span></div>`;                    } else {                        fallbacksHtml += `<a href="${link.url}" target="_blank" class="fallback-link">${link.name}</a>`;                    }                });                fallbacksHtml += '</div>';            }                        card.innerHTML = `                <h2>${book.stage}</h2>                <p class="book-title">${book.title} - ${book.author}</p>                ${availabilityHtml}                <p><strong>书籍简介：</strong>${book.summary}</p>                <p><strong>推荐理由：</strong>${book.reason}</p>                <div class="links-container">                    ${annaHtml}                    ${zlibHtml}                    ${fallbacksHtml}                </div>            `;            resultsContainer.appendChild(card);        });    }    // ... (createDropdownHTML 函数不变)    function createDropdownHTML(id, label, links) { /* ... */ }    // =======================================================    // 带有超时和健壮重试机制的API调用函数 (不变)    // =======================================================    async function fetchAIResponseWithProxy(promptBody) { /* ... */ }        // =======================================================    // 其他所有辅助函数和事件监听器 (无变化)    // =======================================================    function extractJson(rawText) { /* ... */ }    function displayError(message) { /* ... */ }    function setLoadingState(isLoading, text) { /* ... */ }    function loadKeysFromStorage() { /* ... */ }    function saveKeysToStorage() { /* ... */ }    function renderKeyList() { /* ... */ }    function addKey() { /* ... */ }    function deleteKey(index) { /* ... */ }    function updateUIOnKeyChange() { /* ... */ }    // ... 事件监听器 ...        // 为了方便您完整复制，这里附上所有未修改的辅助函数的压缩版    function createDropdownHTML(e,t,s){let o=`<div class="mirror-links-dropdown" id="${e}" style="display:none;">`;return s&&s.length>0?s.forEach(n=>{const a="Official Site"===n.name;o+=`<a href="${n.url}" target="_blank" class="mirror-link ${a?"official-link":""}">${n.name} ${a?" (官网)":""}</a>`}):o+='<span class="mirror-link-error">未能获取到可用地址。</span>',o+="</div>",`<div class="links-wrapper"><button class="toggle-btn" data-target="${e}">${t}</button>${o}</div>`}    async function fetchAIResponseWithProxy(e){if(currentKeyIndex>=apiKeys.length)throw new Error("您提供的所有API Key都已尝试过或均无效/超时。");const t=apiKeys[currentKeyIndex],s=new AbortController,o=setTimeout(()=>{console.warn(`API 请求超时 (${API_TIMEOUT_MS/1e3}秒)，中止请求...`),s.abort()},API_TIMEOUT_MS);try{const n=await fetch(PROXY_ENDPOINT,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({apiKey:t,body:e}),signal:s.signal});if(clearTimeout(o),!n.ok){const a=await n.json().catch(()=>({}));let r=a.error?.message||`服务器返回错误，状态码: ${n.status}`;throw new Error(r)}const l=await n.json();if(!l.candidates||0===l.candidates.length)throw new Error("API响应格式不正确，缺少'candidates'。");const c=l.candidates[0].content.parts[0].text;return JSON.parse(extractJson(c))}catch(d){if(clearTimeout(o),"AbortError"===d.name)return console.warn(`Key ${t.substring(0,4)}... 超时，尝试下一个Key...`),currentKeyIndex++,fetchAIResponseWithProxy(e);if(d instanceof TypeError||d.message.includes("服务器返回错误"))return console.warn(`Key ${t.substring(0,4)}... 遭遇网络或服务器错误，尝试下一个Key...`,d.message),currentKeyIndex++,fetchAIResponseWithProxy(e);if(d instanceof SyntaxError)throw new Error("AI返回的数据格式不正确，无法解析为JSON。");throw d}}    function extractJson(e){const t=e.match(/```json\s*([\s\S]*?)\s*```/);return t&&t[1]?t[1]:e}    function displayError(e){setLoadingState(!1),resultsContainer.innerHTML=`<div class="error-message"><h3>糟糕，出错了！</h3><p>${e}</p><p>请检查你的网络连接和API Key配置，然后重试。</p></div>`}    function setLoadingState(e,t){searchBtn.disabled=e,e?(searchBtn.textContent=t||"思考中...",resultsContainer.innerHTML="",loadingSpinner.style.display="block",resultsContainer.appendChild(loadingSpinner)):(searchBtn.textContent="生成阅读计划",loadingSpinner.style.display="none")}    function loadKeysFromStorage(){const e=localStorage.getItem("geminiApiKeys");apiKeys=e?JSON.parse(e):[],updateUIOnKeyChange(),renderKeyList()}    function saveKeysToStorage(){localStorage.setItem("geminiApiKeys",JSON.stringify(apiKeys))}    function renderKeyList(){if(keyListUl.innerHTML="",0===apiKeys.length)return void(keyListUl.innerHTML="<li>暂无 API Key。</li>");apiKeys.forEach((e,t)=>{const s=`${e.substring(0,4)}...${e.substring(e.length-4)}`,o=document.createElement("li");o.innerHTML=`<span>${s}</span><button class="delete-key-btn" data-index="${t}" title="删除">&times;</button>`,keyListUl.appendChild(o)})}    function addKey(){const e=apiKeyInput.value.trim();e&&!apiKeys.includes(e)?(apiKeys.push(e),saveKeysToStorage(),renderKeyList(),updateUIOnKeyChange(),apiKeyInput.value=""):apiKeys.includes(e)&&alert("这个 API Key 已经存在了。")}    function deleteKey(e){apiKeys.splice(e,1),saveKeysToStorage(),renderKeyList(),updateUIOnKeyChange()}    function updateUIOnKeyChange(){0===apiKeys.length?(searchBtn.disabled=!0,searchBtn.textContent="请先设置 API Key"):(searchBtn.disabled=!1,searchBtn.textContent="生成阅读计划")}    searchBtn.addEventListener("click",handleSearch),settingsBtn.addEventListener("click",()=>{settingsModal.style.display="flex"}),closeModalBtn.addEventListener("click",()=>{settingsModal.style.display="none"}),settingsModal.addEventListener("click",e=>{e.target===settingsModal&&(settingsModal.style.display="none")}),addKeyBtn.addEventListener("click",addKey),apiKeyInput.addEventListener("keyup",e=>{"Enter"===e.key&&addKey()}),keyListUl.addEventListener("click",e=>{if(e.target.classList.contains("delete-key-btn")){const t=parseInt(e.target.dataset.index,10);deleteKey(t)}});    resultsContainer.addEventListener('click',e=>{if(e.target.classList.contains("toggle-btn")){const t=e.target.dataset.target,s=document.getElementById(t);s&&(s.style.display="none"===s.style.display?"block":"none")}});    loadKeysFromStorage();});